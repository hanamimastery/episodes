<p>With <a href="https://hanamirb.org/blog/2022/11/22/announcing-hanami-200/">Hanami 2.0 being released</a>, there is now a lot of cool, stable stuff we can cover in our screencasts, and one of them is something I was planned to tell about for a while already.</p>
<p><strong>Slices.</strong></p>
<p>A brand new Hanami application comes with the app folder, from which all components are automatically registered in the container.</p>
<p>For small applications this works very well, however, you can organize your app in different ways, which Hanami encourages by design, and <strong>that can be very useful</strong> in working with bigger codebases.</p>
<p>You can do so by extracting parts of your code into slices.</p>
<h1><a href="#meet-slices" aria-hidden="true" class="anchor" id="meet-slices"></a>Meet slices</h1>
<p><a href="https://guides.hanamirb.org/v2.0/app/slices/">Slices</a> are very much independent parts of your application. They import a few general components from the main app, but other than that, they can be prepared and booted <strong>independently</strong> from other slices.</p>
<p><img src="https://hanamimastery.com/images/episodes/36/hanami-slices-hierarchy.png" alt="Hanami slies hierarchy" /></p>
<p>This opens nice opportunities for deploying different parts of your app without loading any unnecessary gems and components!</p>
<p><img src="https://hanamimastery.com/images/episodes/36/loading-only-selected-slices.png" alt="Loading code from selected slices" /></p>
<p>You also can <strong>import and export components from other slices if you want!</strong></p>
<p>But <a href="/episodes/7-untangle-your-app-with-dry-monads">how to organize such modules in my applications</a>? Well, there are a few ways, from which I like two the most and this is what I’ll cover in this video.</p>
<h1><a href="#organize-slices-by-the-interface-type" aria-hidden="true" class="anchor" id="organize-slices-by-the-interface-type"></a>Organize slices by the interface type.</h1>
<p>If I have an application, that consist of the</p>
<ul>
<li>Client-Facing module, mostly optimized for reading</li>
<li><a href="/articles/why-all-apis-are-inconsistent">API module</a></li>
<li>and the Admin Module, where most of the app updates happen,</li>
</ul>
<p>I can use a separate slice for each of them, and when working with API, don’t even load view-specific code or gems. The same can apply to configuring different CI paths, and running specs for different parts of my systems.</p>
<h1><a href="#add-api-slice-in-hanami-2" aria-hidden="true" class="anchor" id="add-api-slice-in-hanami-2"></a>Add API slice in Hanami 2</h1>
<p>Adding a new slice in Hanami 2.0 is extremely easy thanks to the generators Hanami 2.0 came with. I have it the scaffold application already created, and to add an API slice, I just need to run <code>hanami generate slice api</code></p>
<pre style="background-color:#2b303b;" lang="bash"><code>
<span style="color:#8fa1b3;">hanami</span><span style="color:#c0c5ce;"> g slice api
</span><span style="color:#65737e;"># Updated config/routes.rb
</span><span style="color:#65737e;"># Created slices/api/
</span><span style="color:#65737e;"># Created slices/api/action.rb
</span><span style="color:#65737e;"># Created slices/api/actions/.keep
</span>
</code></pre>
<p>It created a new slice for me by creating a few files under the <code>slices/api</code> folder. It also updated the router to properly handle requests under a specific namespace. Let’s check it out.</p>
<p>First of all, in the router's config file, there is a <code>slice</code> method call now, with a block added. Inside I can place all my routes that should be served by my slice. They all will be namespaced under the <code>/api</code> URL.</p>
<pre style="background-color:#2b303b;" lang="ruby"><code>
<span style="color:#65737e;"># config/routes.rb
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;"># ...
</span><span style="color:#c0c5ce;">slice </span><span style="color:#a3be8c;">:api</span><span style="color:#c0c5ce;">, </span><span style="color:#a3be8c;">at: </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">/api</span><span style="color:#c0c5ce;">&quot; </span><span style="color:#b48ead;">do
</span><span style="color:#b48ead;">end
</span>
</code></pre>
<p>Then in the <code>slices</code> folder, you can see an <code>API</code> directory. Inside, I can define all my API-related actions, <a href="/episodes/21-serialization-with-alba">serialization logic</a> and so on.</p>
<p>You can see here, that the structure is almost identical to the main app folder, and therefore it’s quite intuitive to work with slices from the start.</p>
<p>Had you noticed the capitalized <code>API</code> module name here? The word API is automatically recognized as an acronym by the <a href="https://dry-rb.org/gems/dry-inflector">preconfigured inflector</a>, which I had talked about in the <a href="/episodes/4-string-transformations-with-dry-inflector">Episode 4</a>. Make sure you check it out if you want to know more!</p>
<p>With this inflector preconfigured, you can define modules with more intuitive syntax, even though the file names can remain unchanged.</p>
<p>I love this attention to details Hanami team shows by giving us these small touches here and there.</p>
<h1><a href="#add-admin-slice" aria-hidden="true" class="anchor" id="add-admin-slice"></a>Add Admin Slice</h1>
<p>However, my application will also have the Admin Panel, where I’m going to place all the views related to administrating with my list of books. Let me create the admin slice then.</p>
<pre lang="bash" style="background-color:#2b303b;"><code>
<span style="color:#8fa1b3;">hanami</span><span style="color:#c0c5ce;"> g slice admin
</span><span style="color:#65737e;"># Updated config/routes.rb
</span><span style="color:#65737e;"># Created slices/admin/
</span><span style="color:#65737e;"># Created slices/admin/action.rb
</span><span style="color:#65737e;"># Created slices/admin/actions/.keep
</span>
</code></pre>
<p>The admin folder had been created, and you can see, that also some sample test examples had been added to the spec folder.</p>
<p>Finally, I can also provide the very narrow functionality, of presenting books to the community. I’m going to add one more slice, named <code>main</code></p>
<p>However this time, I’m going to explicitly override the URL my slice is mounted upon.</p>
<pre lang="shell" style="background-color:#2b303b;"><code>
<span style="color:#c0c5ce;">hanami g slice main --url=/
</span><span style="color:#c0c5ce;"># Updated config/routes.rb
</span><span style="color:#c0c5ce;"># Created slices/main/
</span><span style="color:#c0c5ce;"># Created slices/main/action.rb
</span><span style="color:#c0c5ce;"># Created slices/main/actions/.keep
</span>
</code></pre>
<p>…and done! Great!</p>
<p>Disclaimer:</p>
<p>Let me put a disclaimer here. For such a small application, you may think that it’s overengineering, and I won’t argue too much. This episode is mostly to show you how you can organize your code in a way your applications will scale well without problems in the future.</p>
<h1><a href="#adding-some-actions" aria-hidden="true" class="anchor" id="adding-some-actions"></a>Adding some actions</h1>
<p>Let me generate a few actions now, so we can present our concepts better. First I’m going to add an endpoint to my admin panel, where I’ll be able to unsubscribe people from new book reviews I’m publishing.</p>
<pre style="background-color:#2b303b;" lang="shell"><code>
<span style="color:#c0c5ce;">hanami g action books.unsubscribe --slice=admin --http=delete
</span>
</code></pre>
<p>When I browse my files, you’ll see that the action had been added to the <em>admin</em> slice, and in the routes, an HTTP method had been set to <code>DELETE</code>.</p>
<p>Then, having hat, I’ll need a few endpoints to interact from the API. I’ll allow people to subscribe and unusbscribe freely, as well as listing some books.</p>
<pre style="background-color:#2b303b;" lang="shell"><code>
<span style="color:#c0c5ce;">hanami g action books.subscribe --slice=api -http=post
</span><span style="color:#c0c5ce;">hanami g action books.unsubscribe --slice=api -http=delete
</span><span style="color:#c0c5ce;">hanami g action books.index --slice=api
</span>
</code></pre>
<p>Finally, I’ll have a dashboard, when I only show list of reviewed books.</p>
<pre style="background-color:#2b303b;" lang="ruby"><code>
<span style="color:#c0c5ce;">hanami g action books.</span><span style="color:#96b5b4;">index </span><span style="color:#c0c5ce;">--slice=main --url=/
</span>
</code></pre>
<p>Now let me open the <code>routes.rb</code> file to check how it all looks now. I can have multiple routes generated in different slices, but as I’ve setup my books list to be loaded under the root URL, I’ll remove the duplicated definition from the top of the file.</p>
<p>When I’ll run a server, and send a <code>DELETE</code> request to the <code>/api/books/unsubscribe</code> URL now, As a response, I’ll get the action class name. This is what each action come with, when generated automatically. Similar thing will be done for the <code>admin</code> namespace.</p>
<p>![Response for API slice action][/images/episodes/36/response-api-slice-action.png]</p>
<p>This shows us that our application recognizes this URL, and serves it properly.</p>
<p>To preview the code, let me open the action file.</p>
<pre lang="ruby" style="background-color:#2b303b;"><code>
<span style="color:#65737e;"># frozen_string_literal: true
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">API
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Actions
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Books
</span><span style="color:#c0c5ce;">      </span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Subscribe </span><span style="color:#eff1f5;">&lt; </span><span style="color:#a3be8c;">API::Action
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">handle</span><span style="color:#c0c5ce;">(*, </span><span style="color:#bf616a;">response</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">          response.body = unsubscribe.</span><span style="color:#96b5b4;">class</span><span style="color:#c0c5ce;">.</span><span style="color:#96b5b4;">name
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">end
</span><span style="color:#c0c5ce;">      </span><span style="color:#b48ead;">end
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">end
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">end
</span><span style="color:#b48ead;">end
</span>
</code></pre>
<p>You can extend this if you wish, but In this episode I want to only focus on slices feature.</p>
<h1><a href="#separate-the-app-and-per-slice-containers" aria-hidden="true" class="anchor" id="separate-the-app-and-per-slice-containers"></a>Separate the App and per-Slice containers</h1>
<p>At this point you probably think: ok, but why? It’s just namespacing, isn’t it? Well, there is more. Let me show you now what all that does for our component registration by opening the hanami console.</p>
<pre style="background-color:#2b303b;" lang="ruby"><code>
<span style="color:#c0c5ce;">hanami console
</span><span style="color:#ebcb8b;">Hanami</span><span style="color:#c0c5ce;">.app.boot
</span>
</code></pre>
<p>I can list my main app registered components by accessing the <code>keys</code> method on it.</p>
<pre style="background-color:#2b303b;" lang="ruby"><code>
<span style="color:#ebcb8b;">Hanamimastery</span><span style="color:#c0c5ce;">::</span><span style="color:#ebcb8b;">App</span><span style="color:#c0c5ce;">.keys
</span><span style="color:#65737e;"># =&gt; [&quot;settings&quot;, &quot;notifications&quot;, &quot;routes&quot;, &quot;inflector&quot;, &quot;logger&quot;, &quot;rack.monitor&quot;]
</span>
</code></pre>
<p>For slices, we have similar access point, but we need to call the <code>Slice</code> constant on the slice name module, instead of <code>App</code>.</p>
<pre style="background-color:#2b303b;" lang="ruby"><code>
<span style="color:#ebcb8b;">Main</span><span style="color:#c0c5ce;">::</span><span style="color:#ebcb8b;">Slice</span><span style="color:#c0c5ce;">.keys
</span><span style="color:#65737e;"># =&gt; [&quot;actions.dashboard.index&quot;, &quot;inflector&quot;, &quot;logger&quot;, &quot;notifications&quot;, &quot;rack.monitor&quot;, &quot;routes&quot;, &quot;settings&quot;]
</span><span style="color:#ebcb8b;">Admin</span><span style="color:#c0c5ce;">::</span><span style="color:#ebcb8b;">Slice</span><span style="color:#c0c5ce;">.keys
</span><span style="color:#65737e;"># =&gt; [&quot;actions.books.unsubscribe&quot;, &quot;actions.books.index&quot;, &quot;inflector&quot;, &quot;logger&quot;, &quot;notifications&quot;, &quot;rack.monitor&quot;, &quot;routes&quot;, &quot;settings&quot;]
</span><span style="color:#ebcb8b;">API</span><span style="color:#c0c5ce;">::</span><span style="color:#ebcb8b;">Slice</span><span style="color:#c0c5ce;">.keys
</span><span style="color:#65737e;"># =&gt; [&quot;actions.books.unsubscribe&quot;, &quot;actions.books.subscribe&quot;, &quot;actions.books.index&quot;, &quot;inflector&quot;, &quot;logger&quot;, &quot;notifications&quot;, &quot;rack.monitor&quot;, &quot;routes&quot;, &quot;settings&quot;]
</span>
</code></pre>
<p>Each slice has separate set of components registered in the container, so if we’ll use separate docker containers for different modules, we can for example, load API without the whole view-related code even being loaded. This can significantly reduce the boot time, deployment, resources usage, CI build time, and so on.</p>
<p>However, can you spot some issues here?</p>
<h1><a href="#organize-slices-based-on-business-vs-application-logic" aria-hidden="true" class="anchor" id="organize-slices-based-on-business-vs-application-logic"></a>Organize slices based on Business Vs Application logic</h1>
<p>Splitting slices by the type of interface can be useful, but even in this little example, you can already see, that a lot of logic here will be duplicated and could be shared between Admin and API. Modules.</p>
<p>This brings us to the other way of splitting our application, <a href="https://martinfowler.com/bliki/BoundedContext.html">based on the business domain</a>.</p>
<h1><a href="#create-business-domain-slice" aria-hidden="true" class="anchor" id="create-business-domain-slice"></a>Create business domain slice</h1>
<p>Let’s assume, I have the part of the system, that allows us to allow people to subscribe to my book reviews. This part of my business domain would be named: <code>Subscribing</code>.</p>
<pre lang="ruby" style="background-color:#2b303b;"><code>
<span style="color:#c0c5ce;">hanami g slice subscribing
</span>
</code></pre>
<p>This slice, would not be created based on the access points from the system, but based on the business logic it contains. Inside, there would not be stored any rendering logic, nor HTTP serving. All that is either <code>API</code> or web-specific.</p>
<p>This <code>subscribing</code> slice, would contain list of <em>service objects</em>, or <em>interactors</em>, that would update my internal application state, send emails, trigger callbacks, and so on.</p>
<h1><a href="#adding-interactors-to-my-slice" aria-hidden="true" class="anchor" id="adding-interactors-to-my-slice"></a>Adding interactors to my slice</h1>
<p>Let me add just two of them.</p>
<pre lang="ruby" style="background-color:#2b303b;"><code>
<span style="color:#65737e;"># slices/subscribing/interactors/subscribe.rb
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Subscribing
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Interactors
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Subscribe
</span><span style="color:#eff1f5;">      </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">call</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">email</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">				</span><span style="color:#65737e;"># create a subscription
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;"># send notification email
</span><span style="color:#c0c5ce;">      </span><span style="color:#b48ead;">end
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">end
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">end
</span><span style="color:#b48ead;">end
</span>
</code></pre>
<pre style="background-color:#2b303b;" lang="ruby"><code>
<span style="color:#65737e;"># slices/subscribing/interactors/unsubscribe.rb
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Subscribing
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Interactors
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Unsubscribe
</span><span style="color:#eff1f5;">      </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">call</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">subscriber_id</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">				</span><span style="color:#65737e;"># find subscirption
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;"># remove it
</span><span style="color:#c0c5ce;">        </span><span style="color:#65737e;"># send notification email
</span><span style="color:#c0c5ce;">      </span><span style="color:#b48ead;">end
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">end
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">end
</span><span style="color:#b48ead;">end
</span>
</code></pre>
<p>I don’t want to go into the logic here, sorry, because I only want to focus on the code organization part in this episode. So how this new slice could be useful for us?</p>
<h1><a href="#sharing-components-across-slices" aria-hidden="true" class="anchor" id="sharing-components-across-slices"></a>Sharing components across slices</h1>
<p>Well, one benefit from doing this, could be that we can import all the components into any slice we want. We can use our interactors in both <code>API</code> and <code>Admin</code> panel, while maintain the HTTP handling separately.</p>
<p><img src="https://hanamimastery.com/images/episodes/36/diagram-sharing-components.png" alt="Diagram: Sharing components across slices" /></p>
<p>To do this, I just need to add the slice-specific configuration files.</p>
<h1><a href="#configure-hanami-slices-to-import-components" aria-hidden="true" class="anchor" id="configure-hanami-slices-to-import-components"></a>Configure Hanami slices to import components</h1>
<p>I’m going to allow people to subscribe to book reviews and unsubscribe from them freely.</p>
<pre style="background-color:#2b303b;" lang="ruby"><code>
<span style="color:#65737e;"># config/slices/api.rb
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">API
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Slice </span><span style="color:#eff1f5;">&lt; </span><span style="color:#a3be8c;">Hanami::Slice
</span><span style="color:#c0c5ce;">    import </span><span style="color:#a3be8c;">from: :subscribing
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">end
</span><span style="color:#b48ead;">end
</span>
</code></pre>
<p>However, for my Admin panel, I don’t want any of my employees to accidentially subscribe anyone against their will, so I only allow to unsubscribe people who already subscribed.</p>
<pre lang="ruby" style="background-color:#2b303b;"><code>
<span style="color:#65737e;"># config/slices/admin.rb
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Admin
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Slice </span><span style="color:#eff1f5;">&lt; </span><span style="color:#a3be8c;">Hanami::Slice
</span><span style="color:#c0c5ce;">    import </span><span style="color:#a3be8c;">keys: </span><span style="color:#c0c5ce;">[&#39;</span><span style="color:#a3be8c;">interactors.unsubscribe</span><span style="color:#c0c5ce;">&#39;], </span><span style="color:#a3be8c;">from: :subscribing</span><span style="color:#c0c5ce;">, </span><span style="color:#a3be8c;">as: :subscriptions
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">end
</span><span style="color:#b48ead;">end
</span>
</code></pre>
<p>I’ll rename the subscribing slice in the Admin context to <code>subscriptions</code>, just to show this functionality.</p>
<h1><a href="#use-imported-external-components-in-actions" aria-hidden="true" class="anchor" id="use-imported-external-components-in-actions"></a>Use imported external components in actions</h1>
<p>With this, I can open my actions, and access my imported interactors freely from there! Let me open the API subscribe action and add the new interactor.</p>
<pre style="background-color:#2b303b;" lang="ruby"><code>
<span style="color:#65737e;"># slices/api/actions/books/unsubscribe.rb
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">API
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Actions
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Books
</span><span style="color:#c0c5ce;">      </span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Subscribe </span><span style="color:#eff1f5;">&lt; </span><span style="color:#a3be8c;">API::Action
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">include </span><span style="color:#ebcb8b;">Deps</span><span style="color:#c0c5ce;">[
</span><span style="color:#c0c5ce;">          &#39;</span><span style="color:#a3be8c;">subscribing.interactors.subscribe</span><span style="color:#c0c5ce;">&#39;
</span><span style="color:#c0c5ce;">        ]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">handle</span><span style="color:#c0c5ce;">(*, </span><span style="color:#bf616a;">response</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">          response.body = subscribe.</span><span style="color:#96b5b4;">class</span><span style="color:#c0c5ce;">.</span><span style="color:#96b5b4;">name
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">end
</span><span style="color:#c0c5ce;">      </span><span style="color:#b48ead;">end
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">end
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">end
</span><span style="color:#b48ead;">end
</span>
</code></pre>
<pre lang="ruby" style="background-color:#2b303b;"><code>
<span style="color:#65737e;"># slices/admin/actions/books/unsubscribe.rb
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Admin
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Actions
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Books
</span><span style="color:#c0c5ce;">      </span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Unsubscribe </span><span style="color:#eff1f5;">&lt; </span><span style="color:#a3be8c;">Admin::Action
</span><span style="color:#c0c5ce;">        </span><span style="color:#8fa1b3;">include </span><span style="color:#ebcb8b;">Deps</span><span style="color:#c0c5ce;">[
</span><span style="color:#c0c5ce;">          &#39;</span><span style="color:#a3be8c;">subscriptions.interactors.unsubscribe</span><span style="color:#c0c5ce;">&#39;
</span><span style="color:#c0c5ce;">        ]
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">handle</span><span style="color:#c0c5ce;">(*, </span><span style="color:#bf616a;">response</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">          response.body = unsubscribe.</span><span style="color:#96b5b4;">class</span><span style="color:#c0c5ce;">.</span><span style="color:#96b5b4;">name
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">end
</span><span style="color:#c0c5ce;">      </span><span style="color:#b48ead;">end
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">end
</span><span style="color:#c0c5ce;">  </span><span style="color:#b48ead;">end
</span><span style="color:#b48ead;">end
</span>
</code></pre>
<p>Now sending the request to each of the URLs, will return the name of the included component to prove, it’s loaded properly.</p>
<p><img src="https://hanamimastery.com/images/episodes/36/api-unsubscribe-imported-component.png" alt="Response from API slice with impoted component" /></p>
<h1><a href="#resolving-parts-of-the-app" aria-hidden="true" class="anchor" id="resolving-parts-of-the-app"></a>Resolving parts of the app.</h1>
<p>Importing components across slices is just one thing, but you can do even more with them. You can list slices, that can should be loaded in your cluster, and all the rest will be ignored.</p>
<pre lang="ruby" style="background-color:#2b303b;"><code>
<span style="color:#b48ead;">module </span><span style="color:#c0c5ce;">Hanamimastery
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">App </span><span style="color:#eff1f5;">&lt; </span><span style="color:#a3be8c;">Hanami::App
</span><span style="color:#c0c5ce;">		config.slices = [&quot;</span><span style="color:#a3be8c;">api</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">subscribing</span><span style="color:#c0c5ce;">&quot;]
</span><span style="color:#c0c5ce;">	</span><span style="color:#b48ead;">end
</span><span style="color:#b48ead;">end
</span>
</code></pre>
<p>This way, I can configure my list of slices using environment variables, and only parts of my application will be loaded dependeing on my configuration!</p>
<p>Let me show you very quickly. Now, if I’ll open my hanami console, I will not have <code>Main</code> nor <code>Admin</code> slices available anymore.</p>
<p><img src="https://hanamimastery.com/images/episodes/36/console-slices-not-loaded.png" alt="Not loaded slices in the console" /></p>
<p>This brings a whole new set of opportunities to developing scalable applications in Ruby, without the need to slow down development when the codebase grow.</p>
<h1><a href="#summary" aria-hidden="true" class="anchor" id="summary"></a>Summary</h1>
<p>Slices in Hanami are insanely powerful, allowing us to completely control</p>
<ul>
<li>how and when our application is loaded,</li>
<li>which dependencies are resolved and setup</li>
<li>reduce duplication and coupling.</li>
</ul>
<p>There are multiple ways you can organize your slices, but I hope the two ideas I’ve shown you above will give you some portion of inspiration.</p>
<h1><a href="#thanks" aria-hidden="true" class="anchor" id="thanks"></a>Thanks</h1>
<p>I want to especially thank my recent sponsors,</p>
<ul>
<li><a href="http://prowly.com">prowly.com</a></li>
<li><a href="https://twitter.com/akilasy">Akilas Yemane</a></li>
<li><a href="https://github.com/btihen">Bill Tihen</a></li>
</ul>
<p>for supporting this project, I really appreciate it!</p>
<ul>
<li><a href="https://unsplash.com/@perfectcoding">Nikolai Chernichenko</a> - for the great cover image</li>
</ul>
